@startuml ticket_purchase_flow
!theme plain

title Ticket Purchase Flow - Clean Architecture Perspective

actor User
participant "Frontend" as FE
participant "User Handler" as UH
participant "UserUseCase" as UUC
box "Application Layer" #LightGreen
    participant "AuthNService" as AuthN
    participant "EventMgrService\n(interface)" as EMS
end box
box "Infrastructure Layer" #LightBlue
    participant "EventMgr\nHTTP Adapter" as EMHA
    participant "ServiceAuthClient" as SAC
end box
participant "EventManager\nService" as EM
participant "IDM Service" as IDM

User -> FE : Buy ticket for Event 42
activate FE

FE -> UH : POST /users/{id}/tickets\nAuthorization: Bearer <token>
activate UH

UH -> UUC : CreateTicketForUser(userID, token, eventID)
activate UUC

note right of UUC
    **Use Case Responsibilities:**
    1. Authenticate user
    2. Verify ownership
    3. Coordinate external service
    4. Update local state
end note

UUC -> AuthN : WhoIsUser(token)
activate AuthN

AuthN -> IDM : VerifyToken(token) [gRPC]
activate IDM

IDM --> AuthN : UserIdentity{UserID, Email, Role}
deactivate IDM

AuthN --> UUC : UserIdentity
deactivate AuthN

UUC -> UUC : Verify token.Email == user.Email
note right: Authorization check

UUC -> EMS : CreateTicket(code, nil, eventID)
activate EMS
note right of EMS
    Interface in Application Layer
    (Dependency Inversion Principle)
end note

EMS -> EMHA : CreateTicket(ctx, code, nil, eventID)
activate EMHA

EMHA -> SAC : GetServiceToken()
activate SAC

SAC -> IDM : Login(service_email, service_pass)
activate IDM
IDM --> SAC : service_token
deactivate IDM

SAC --> EMHA : service_token
deactivate SAC

EMHA -> EM : POST /tickets\nAuthorization: Bearer <service_token>\n{code, event_id: 42}
activate EM

note right of EM
    **EventManager processes:**
    1. Authenticate service client
    2. Authorize ticket creation
    3. Validate seat availability
    4. Create ticket
end note

EM -> EM : EventUseCase.CreateTicket()
EM -> EM : TicketService.validateSeatAvailability()
EM -> EM : TicketRepository.Create()

EM --> EMHA : Ticket{Code, EventID, PacketID}
deactivate EM

EMHA --> EMS : TicketResponse
deactivate EMHA

EMS --> UUC : TicketResponse
deactivate EMS

UUC -> UUC : Delegate to UserService
note right
    ✅ UserService handles:
    • Ticket creation coordination
    • User ticket list updates
    • Business logic
end note

UUC -> UUC : userService.CreateTicketForUser()

UUC --> UH : ticketCode
deactivate UUC

UH --> FE : 201 Created\n{ticket_code: "uuid..."}
deactivate UH

FE --> User : Ticket purchased!
deactivate FE

note bottom
    **Clean Architecture Observations:**

    ✅ Good:
    • Clear layer separation
    • Service interface in application layer
    • Adapter pattern for HTTP client
    • Service-to-service authentication

    ⚠️ Minor Issues:
    • No compensation/rollback for distributed failures
    • Could benefit from event-driven architecture

    ✅ Good Architecture:
    • UserService layer exists and used properly
    • Clean separation of concerns
    • Proper delegation patterns
end note

@enduml
