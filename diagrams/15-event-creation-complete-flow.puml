@startuml event_creation_complete_flow
!theme plain

title Event Creation - Complete Flow with Clean Architecture Analysis

actor "Event Owner" as Owner
participant "Frontend" as FE

box "Presentation Layer" #LightPink
    participant "Gin Handler" as GH
    participant "HTTP DTOs" as DTO
end box

box "Application Layer - Use Cases" #LightGreen
    participant "EventUseCase" as EUC
end box

box "Application Layer - Services" #PaleGreen
    participant "EventService" as ES
    participant "AuthNService\n(interface)" as AuthN
    participant "AuthZService\n(interface)" as AuthZ
end box

box "Application Layer - Repository Interfaces" #LightGreen
    participant "IEventRepository" as IER
    participant "IInclusionRepo" as IIR
end box

box "Infrastructure Layer" #LightBlue
    participant "RealAuthService\n(impl)" as RAS
    participant "GormEventRepo\n(impl)" as GER
    participant "IDM gRPC Client" as IDMClient
end box

participant "IDM Service" as IDM
database "PostgreSQL\nevent_db" as DB

== Request Arrives ==

Owner -> FE : Create event\n"Summer Festival"
activate FE

FE -> GH : POST /events\nAuthorization: Bearer <token>\n{\n  "name": "Summer Festival",\n  "seats": 1000,\n  "owner_id": 5\n}
activate GH

GH -> DTO : Parse request body
activate DTO
DTO --> GH : HttpEvent DTO
deactivate DTO

GH -> GH : Convert DTO → domain.Event
note right: DTO to Domain mapping

GH -> EUC : CreateEvent(ctx, token, event)
activate EUC

== Authentication (Application Layer) ==

note right of EUC
    **UseCase Responsibility 1:**
    Authenticate the user
end note

EUC -> AuthN : WhoIsUser(ctx, token)
activate AuthN
note right of AuthN
    Interface in Application Layer
    Implementation in Infrastructure
    (Dependency Inversion Principle ✅)
end note

AuthN -> RAS : (interface call)
activate RAS

RAS -> IDMClient : VerifyToken(token)
activate IDMClient

IDMClient -> IDM : gRPC VerifyTokenRequest
activate IDM
IDM -> IDM : Parse JWT
IDM -> IDM : Check expiration
IDM -> IDM : Check blacklist
IDM --> IDMClient : VerifyTokenResponse{\n  valid: true,\n  userId: "5",\n  role: "owner-event"\n}
deactivate IDM

IDMClient --> RAS : Response
deactivate IDMClient

RAS --> AuthN : UserIdentity{UserID: 5, Role: "owner-event"}
deactivate RAS

AuthN --> EUC : UserIdentity
deactivate AuthN

== Authorization (Application Layer) ==

note right of EUC
    **UseCase Responsibility 2:**
    Check authorization
end note

EUC -> AuthZ : CanUserCreateEvent(ctx, identity)
activate AuthZ
note right of AuthZ
    DummyAuthorizationService
    Returns true (allows all)

    ⚠️ Production should have
    proper RBAC/ABAC rules
end note
AuthZ --> EUC : true
deactivate AuthZ

== Validation (Application Layer) ==

note right of EUC
    **UseCase Responsibility 3:**
    Delegate to service for
    business logic
end note

EUC -> EUC : validateEvent(event)
note right
    ⚠️ ISSUE: Duplicate validation
    This should ONLY be in EventService
end note

== Business Logic (CURRENT - Direct Repository Call) ==

note right of EUC
    ❌ VIOLATION:
    UseCase calls repository directly
    bypassing the service layer!
end note

EUC -> IER : Create(ctx, event)
activate IER

IER -> GER : (interface call)
activate GER

GER -> DB : INSERT INTO events\n(name, seats, owner_id, ...)\nVALUES (...)
activate DB
DB --> GER : Event row with ID
deactivate DB

GER --> IER : domain.Event{ID: 123, ...}
deactivate GER

IER --> EUC : Created event
deactivate IER

EUC --> GH : domain.Event
deactivate EUC

== Response ==

GH -> GH : Convert domain → DTO
GH -> DTO : AddHATEOASLinks(event)
activate DTO
note right
    Adds links to:
    - self
    - update
    - delete
    - packets
end note
DTO --> GH : HttpEvent with links
deactivate DTO

GH --> FE : 201 Created\n{\n  "id": 123,\n  "name": "Summer Festival",\n  "seats": 1000,\n  "links": {...}\n}
deactivate GH

FE --> Owner : Event created successfully!
deactivate FE

== What SHOULD Happen ==

note over EUC, ES
    **CORRECT FLOW:**

    UseCase should call:
    EUC -> ES : CreateEvent(ctx, event)

    Service validates and handles business logic:
    ES -> ES : validateEvent(event)
    ES -> IER : Create(ctx, event)

    This keeps:
    • Validation in ONE place (service)
    • Business logic in service layer
    • UseCase thin and focused on orchestration
end note

note bottom
    **Clean Architecture Scoring for Event Creation:**

    ✅ Strengths (70%):
    • Clear layer separation
    • Dependency inversion (interfaces in app layer)
    • Domain-driven design (domain.Event entity)
    • Proper authentication/authorization abstraction
    • HATEOAS for REST maturity
    • DTO to Domain conversion

    ❌ Violations (30%):
    • UseCase bypasses service layer
    • Duplicate validation logic
    • Business logic scattered

    **Score: 7.5/10**

    **To reach 10/10:**
    1. Always route through EventService
    2. Remove validation from UseCase
    3. Centralize all business logic in Service layer
end note

@enduml
